## [3208. 交替组 II](https://leetcode.cn/problems/alternating-groups-ii/)

给你一个整数数组 `colors` 和一个整数 `k` ，`colors`表示一个由红色和蓝色瓷砖组成的环，第 `i` 块瓷砖的颜色为 `colors[i]` ：

- `colors[i] == 0` 表示第 `i` 块瓷砖的颜色是 **红色** 。
- `colors[i] == 1` 表示第 `i` 块瓷砖的颜色是 **蓝色** 。

环中连续 `k` 块瓷砖的颜色如果是 **交替** 颜色（也就是说除了第一块和最后一块瓷砖以外，中间瓷砖的颜色与它 **左边** 和 **右边** 的颜色都不同），那么它被称为一个 **交替** 组。

请你返回 **交替** 组的数目。

**注意** ，由于 `colors` 表示一个 **环** ，**第一块** 瓷砖和 **最后一块** 瓷砖是相邻的。



此题有多种解法，最开始想到的环链表反而是最不好写的做法。可以使用动态规划+滑动窗口进行优化

初始思路为：维护两个指针`left` `right`，在其中进行遍历下标`i`，如果`i`与`i-1`的值相等，则窗口右移。

但只维护一个指针即可，且后面的窗口与前面的窗口**有部分重合**，可使用动态规划分为子问题：

- 当前两个是否不同
- 当前不同数 = 之前连续不同数 + 现在是否不同

因此仅需要维护一个指针，记录`连续不同总数`即可，如果遇到相同，连续不同数清零。

代码如下：

```
class Solution {
public:
    int numberOfAlternatingGroups(vector<int>& colors, int k) {
        int n = colors.size();
        int ans = 0, cnt = 0;
        for (int i = 0; i < n + k - 1; i++) {
            if (i > 0 && colors[i % n] == colors[(i - 1) % n]) {
                cnt = 0;
            }
            cnt++;
            ans += cnt >= k;
        }
        return ans;
    }
};
```

### 知识点

* 当涉及到环结构时，不仅可以使用环状链表进行遍历，还可以使用`i % 单轮循环长度`进行再次遍历

- 当问题有部分重合时，可以考虑到将结果**记忆化**来优化代码